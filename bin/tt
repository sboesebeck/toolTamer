#!/usr/bin/env bash

if [ "q$1" = "q-sh" ]; then
  cd "$(dirname $0)"
  echo "export PATH=\$PATH:$(pwd)"
  exit
fi

trap cleanup EXIT QUIT TERM

GN='\033[0;32m'
RD='\033[0;31m'
BL='\033[0;34m'
YL='\033[0;33m'
MG='\033[0;35m'
CN='\033[0;36m'

RESET="\033[0m"

ERR=$RD
WR=$YL

if [ ! -e $(dirname $0)/include.sh ]; then
  echo "$(dirname $0)/include.sh not found"
  exit 1
fi
source $(dirname $0)/include.sh
cd $(dirname $0)

if which tt >/dev/null; then
  log "tt is in path - ${GN}ok$RESET"
else
  log "${YL}Warning:${RESET} ToolTamer not in path - please add the following line to your config:"
  log "eval \$($(pwd)/tt -sh)"
fi
BINDIR=$(pwd)

function cleanup() {
  echo "Cleaning up"
  rm -rf $TMP
}

function logn() {
  echo -ne "$1"
}
function log() {
  echo -e "$1"
}

function err() {
  echo -e "${ERR}error:$RESET $1"
}

function warn() {
  echo -e "${WR}Warning:$RESET $1"
}

function logf() {
  echo -e "$1" >>$TMP/log
}

function show_help() {
  cat <<EOF
ToolTamer - automate installing tools and syncing configuration files.

Usage: $(basename "$0") [option]

Options
  --syncSys         Install/uninstall packages, sync managed files, and run local installers.
  --syncFilesOnly   Update managed files without touching packages.
  --updateToolTamer Snapshot package list into ToolTamer (installed tools only).
  --updateToolTamerFiles Snapshot package list and managed files into ToolTamer.
  --admin           Open the admin helper menu (moving files, deduping packages, etc.).
  -h, --help        Show this help text and exit.

No option starts the interactive menu. If fzf is installed, the menu uses an fzf picker (with colors) for navigation.
EOF
}

DEFAULT_CONFIG_PATTERNS=()
DEFAULT_PATTERN_FALLBACK=(
  ".bashrc"
  ".bash_profile"
  ".bash_aliases"
  ".profile"
  ".zshrc"
  ".zlogin"
  ".zlogout"
  ".zprofile"
  ".zshenv"
  ".gitconfig"
  ".ssh/config"
)

function tt_relpath_from_home() {
  local path="$1"
  local rel="${path#$HOME/}"
  if [ "$rel" = "$path" ]; then
    rel="${path#$HOME}"
  fi
  rel="${rel#/}"
  if [ -z "$rel" ]; then
    rel=$(basename "$path")
  fi
  echo "$rel"
}

function add_file_to_config_store() {
  local config_name="$1"
  local source="$2"
  local dest="$3"
  if [ ! -f "$source" ]; then
    return 1
  fi
  local config_dir="$BASE/configs/$config_name"
  local files_dir="$config_dir/files"
  local files_conf="$config_dir/files.conf"
  if [ ! -e "$files_conf" ]; then
    touch "$files_conf"
  fi
  local rel
  rel=$(tt_relpath_from_home "$dest")
  local repo_file="$files_dir/$rel"
  mkdir -p "$(dirname "$repo_file")"
  local action="updated"
  if [ ! -e "$repo_file" ]; then
    action="added"
  else
    local src_hash
    local repo_hash
    src_hash=$(shasum <"$source")
    repo_hash=$(shasum <"$repo_file")
    if [ "$src_hash" = "$repo_hash" ]; then
      if ! grep -Fq ";$dest" "$files_conf" 2>/dev/null; then
        echo "$rel;$dest" >>"$files_conf"
      fi
      return 1
    fi
  fi
  cp "$source" "$repo_file"
  if ! grep -Fq ";$dest" "$files_conf" 2>/dev/null; then
    echo "$rel;$dest" >>"$files_conf"
  fi
  local action_label="Updated"
  if [ "$action" = "added" ]; then
    action_label="Added"
  fi
  log "  ${GN}$action_label$RESET ${BL}$dest$RESET for ${BL}$config_name$RESET"
  return 0
}

function seed_default_config_files() {
  local config_name="$1"
  local config_dir="$BASE/configs/$config_name"
  local files_conf="$config_dir/files.conf"
  if [ ! -e "$files_conf" ]; then
    touch "$files_conf"
  fi
  if [ -s "$files_conf" ]; then
    return
  fi
  log "Seeding default config files for ${BL}$config_name$RESET"
  local added=0
  for pattern in "${DEFAULT_CONFIG_PATTERNS[@]}"; do
    while IFS= read -r match; do
      [ -z "$match" ] && continue
      add_file_to_config_store "$config_name" "$match" "$match" && added=1
    done < <(compgen -G "$HOME/$pattern" 2>/dev/null || true)
  done
  if [ -d "$HOME/.config" ]; then
    while IFS= read -r cfg_file; do
      [ -z "$cfg_file" ] && continue
      case "$cfg_file" in
      *.conf | *.cfg | *.ini | *.toml | *.yaml | *.yml | *.json | *.vim | */config)
        add_file_to_config_store "$config_name" "$cfg_file" "$cfg_file" && added=1
        ;;
      esac
    done < <(find "$HOME/.config" -maxdepth 2 -type f 2>/dev/null)
  fi
  if [ "$added" -eq 0 ]; then
    log "  ${YL}No default files$RESET detected under $HOME for $config_name"
  fi
}

function pause_before_menu() {
  if [ -t 1 ]; then
    echo
    log "${CN}Press enter to return to the menu...$RESET"
    read -r </dev/tty
    echo
  fi
}

function syncFile() {
  if [ -z "$1" ] && [ -z "$2" ]; then
    return
  fi
  dotfile="$1"
  gitfile="$2"

  if [ "q$dotfile" = "q" ] || [ "q$gitfile" = "q" ]; then
    logf "Cannot sync '$dotfile' to '$gitfile'"
    return
  fi

  logn "Comparing ${GN}$dotfile${RESET} <-> ${BL}${gitfile##$BASE/configs/}${RESET}....."
  if [ -e "$dotfile" ]; then
    s1=$(shasum <"$dotfile")
    s2=$(shasum <"$gitfile")
    if [ "$s1" = "$s2" ]; then
      log "${GREEN}Ok${RESET}"
    else
      log "${YL}files differ...${RESET} - replacing"
      if [ ! -d $(dirname $dotfile) ]; then
        mkdir -p $(dirname $dotfile)
      fi
      if [ -e "$dotfile" ]; then
        mv "$dotfile" "$dotfile.ttbak"
      fi
      cp "$gitfile" "$dotfile" || err "Copy failed"
    fi
  else
    log "${RED}no $dotfile${RESET}"
    if [ ! -d $(dirname $dotfile) ]; then
      mkdir -p $(dirname $dotfile)
    fi
    if [ -e "$dotfile" ]; then
      mv "$dotfile" "$dotfile.ttbak"
    fi
    cp "$gitfile" "$dotfile" || err "Copy failed"
  fi
}

function updateTTFromInstallation() {
  log "Comparing current system with ToolTamer files, updating ToolTamer"
  bash -c "$LIST" | while read l; do
    logn "Checking $l..."
    found=0
    for c in common $(<$BASE/configs/$HOST/includes.conf) $HOST; do
      if grep $l $BASE/configs/$c/to_install.$INSTALLER >/dev/null 2>&1; then
        log "${GN}in $l${RESET}"
        found=1
        break
      fi
    done
    if [ $found -eq 0 ]; then
      log "${RD}Missing$RESET - adding to Host"
      echo "$l" >>$BASE/configs/$HOST/to_install.$INSTALLER
    fi

  done

}

function syncInstall() {

  logn "Preparing list of software for $HOST..."
  for c in common $(<$BASE/configs/$HOST/includes.conf) $HOST; do
    cat $BASE/configs/$c/to_install.$INSTALLER >>$TMP/to_install
  done
  sort -u $TMP/to_install >$TMP/to_install.sorted
  logn "$(wc -l $TMP/to_install.sorted | cut -c1-9) tools to install. "
  log "${GN}done$RESET"
  echo
  log "now: running through all localy installed software"
  logn "Checking: "
  bash -c "$LIST" >$TMP/local_installed
  cat $TMP/local_installed | while read l; do
    if [ -z "$l" ]; then
      continue
    fi
    if [[ "$l" =~ "=" ]]; then
      continue
    fi
    if [[ "$l" =~ "#" ]]; then
      continue
    fi
    if ! grep "$l" $TMP/to_install.sorted >/dev/null 2>&1; then
      if [[ "$l" =~ "lib" ]]; then
        logn "${YL}L$RESET"
        logf "Assuming $l is a lib - not uninstalling"
      else
        U=$(echo "$USES" | sed -e "s/%%/$l/g")
        deps=$(bash -c "$U" | wc -w)
        if [ "$deps" -gt 0 ]; then
          logn "${YL}D$RESET"
          logf "$l is dependency of $deps packages"
          logf "adding $l to install list for $HOST"
          echo "$l" >>$BASE/configs/$HOST/to_install.$INSTALLER
        else
          logn "${RD}R${RESET}"
          logf "Removing ${RD}$l$RESET from system - is not in list"
          $UNINSTALL $l || err "Uninstall of $l failed"
        fi
      fi
    else
      logn "${GN}.$RESET"
    fi
  done
  log "${GN}ok$RESET"
  log "now running through all to be installed"
  logn "Checking: "
  cat $TMP/to_install.sorted | while read l; do

    if [ -z "$l" ]; then
      continue
    fi
    if [[ "$l" =~ "=" ]]; then
      continue
    fi
    if [[ "$l" =~ "#" ]]; then
      continue
    fi
    if ! grep "$l" $TMP/local_installed >/dev/null 2>&1; then
      $INSTALL "$l" </dev/tty >>$TMP/log 2>&1 && logn "${GN}I$RESET" || {
        logf "Installation of $l failed"
        logn "${RD}E$RESET"
      }
    else
      logn "."
    fi
  done
  log "${GN}ok$RESET"

  if [ "$OS_TYPE" = "Darwin" ]; then
    log "Checking taps"
    brew tap >$TMP/local_taps
    for i in common $(<$BASE/configs/$HOST/includes.conf) $HOST; do
      if [ -e $BASE/configs/$i/taps ]; then
        cat $BASE/configs/$i/taps >>$TMP/taps
      fi
    done
    sort -u $TMP/taps >$TMP/taps.sorted
    cat $TMP/local_taps | while read l; do
      if ! grep $l $TMP/taps.sorted >/dev/null 2>&1; then
        logn "${RD}R$RESET"
        logf "Removing tap $l"
        brew untap $l || err "Untapping $l failed"
      else
        logn "."
      fi
    done
    cat $TMP/taps.sorted | while read l; do
      if ! grep $l $TMP/local_taps >/dev/null; then
        brew tap $l || err "Tapping $l failed"
        logn "${GN}I$RESET"
      else
        logn "."
      fi
    done
    log "${GN}ok$RESET"
  fi

}

function syncTTtoSystemFiles() {
  log "Updating local files from TT."
  createEffectiveFilesList $TMP/to_copy.lst
  #echo >$TMP/to_copy.lst

  #for i in common $(<$BASE/configs/$HOST/includes.conf) $HOST; do
  #  cat $BASE/configs/$i/files.conf | while read l; do
  #    f=$(echo $l | cut -f1 -d\;)
  #    d=$(echo $l | cut -f2 -d\;)
  #    if [ -z "$f" ]; then
  #      continue
  #    fi
  #    if [[ "$f" =~ "#" ]]; then
  #      continue
  #    fi
  #    #log "Syncing file $f with ~/$d"
  #    if [ "$d" != "${d%/}" ]; then
  #      #ends with /
  #      d=$d$(basename "$f")
  #    fi
  #    if grep ";$HOME/$d" $TMP/to_copy.lst >/dev/null; then
  #      grep -v ";$HOME/$d" $TMP/to_copy.lst >$TMP/to_copy.tmp || {
  #        err "error"
  #        exit 1
  #      }
  #      mv $TMP/to_copy.tmp $TMP/to_copy.lst
  #    fi
  #    echo "$BASE/configs/$i/files/$f;$HOME/$d" >>$TMP/to_copy.lst
  #  done
  #done
  cat $TMP/to_copy.lst | while read l; do
    f=$(echo "$l" | cut -f1 -d\;)
    d=$(echo "$l" | cut -f2 -d\;)
    syncFile "$d" "$f"
  done
}

function updatingTTFromSystemFiles() {
  log "Updating ToolTamer files from this system."
  createEffectiveFilesList $TMP/to_copy.lst
  local updated=0
  local skipped=0
  while IFS= read -r entry; do
    if [ -z "$entry" ]; then
      continue
    fi
    local gitfile="${entry%%;*}"
    local dotfile="${entry##*;}"
    if [ -z "$gitfile" ] || [ -z "$dotfile" ]; then
      continue
    fi
    if [ ! -e "$dotfile" ]; then
      log "  ${YL}Skip${RESET} missing $dotfile"
      ((skipped = skipped + 1))
      continue
    fi
    if [ -d "$dotfile" ]; then
      log "  ${YL}Skip${RESET} $dotfile (directory sync not supported)"
      ((skipped = skipped + 1))
      continue
    fi
    mkdir -p "$(dirname "$gitfile")"
    if [ -e "$gitfile" ]; then
      local sys_hash
      local repo_hash
      sys_hash=$(shasum <"$dotfile")
      repo_hash=$(shasum <"$gitfile")
      if [ "$sys_hash" = "$repo_hash" ]; then
        continue
      fi
    fi
    cp "$dotfile" "$gitfile"
    log "  ${GN}Captured${RESET} ${dotfile#$HOME/} -> ${gitfile##$BASE/configs/}"
    ((updated = updated + 1))
  done < $TMP/to_copy.lst
  if [ "$updated" -eq 0 ]; then
    log "${YL}No file changes${RESET} detected for ToolTamer."
  else
    log "${GN}Updated $updated file(s)$RESET from this system."
  fi
  if [ "$skipped" -gt 0 ]; then
    log "${YL}Skipped $skipped file(s)$RESET (missing or unsupported types)."
  fi
}
function runLocalInstall() {
  for c in common $(<$BASE/configs/$HOST/includes.conf) $HOST; do
    if [ -e $BASE/configs/$c/local_install.sh ]; then
      log "Running local installation script from ${BL}$c$RESET settings" | lolcat
      source $BASE/configs/$c/local_install.sh
      log "Done."
      echo
    else
      log "No local installation script for $c"
    fi
  done
}

####### MAIN ######
#####
####

#BASE=$(dirname $0)/..
BASE=$HOME/.config/toolTamer/
TMP=/tmp/tt$$
mkdir $TMP
touch $TMP/log
cd $BASE

##### STARTUP
log "---------> ${CN}Tool${GN}Tamer ${MG}V1.0$RESET <-----------"
echo " "
#git pull >/dev/null || exit 1

checkSystem

HOST="$(hostname)"
log "Trying to tame all tools in all your systems. This is $BL$HOST$RESET - OS is $BL$OS_TYPE$RESET and the installer used here is $BL$INSTALLER$RESET"

if [ ! -e $BASE ]; then
  log "No config - enter gitlab url to checkout config dir - ctrl-c to abort...(empty for no clone)"

  read u
  if [ ! -z "$u" ]; then
    git clone $u $BASE || {
      err "Checkout failed!"
      exit 1
    }
    log "${GN}Success$RESET checking out config"
  else
    log "No URL provided- create empty default? (enter / ctrl-c)"
    read
    mkdir -p $BASE/configs/common/files
    touch $BASE/configs/common/to_install.brew
    touch $BASE/configs/common/to_install.apt
cat <<'EOF' >$BASE/tt.conf
# automatically update configs from repo. Valid values are true, false and ask.
GIT_AUTO_UPDATE=ask

# Set to true to skip seeding default files when creating a new host config.
TT_DISABLE_PATTERN_FALLBACK=false

# Default file patterns to import when creating a new host config. Override here if desired.
DEFAULT_CONFIG_PATTERNS=(
  ".bashrc"
  ".bash_profile"
  ".bash_aliases"
  ".profile"
  ".zshrc"
  ".zlogin"
  ".zlogout"
  ".zprofile"
  ".zshenv"
  ".gitconfig"
  ".ssh/config"
)
EOF

    mkdir -p $BASE/configs/$HOST/files
    touch $BASE/configs/$HOST/files.conf
    touch $BASE/configs/$HOST/to_install.$INSTALLER
    touch $BASE/configs/$HOST/includes.conf
    if [ "$INSTALLER" = "brew" ]; then
      touch $BASE/configs/$HOST/taps
    fi

    seed_default_config_files "$HOST"
    log "done"

    echo "Configuration for common/$HOST created. But this is only a start - please have a closer look at $BASE/config/$HOST" | lolcat
  fi
fi
GIT_AUTO_UPDATE=ask
source $BASE/tt.conf

TT_DISABLE_PATTERN_FALLBACK=${TT_DISABLE_PATTERN_FALLBACK:-false}
if [ ${#DEFAULT_CONFIG_PATTERNS[@]} -eq 0 ] && [ "$TT_DISABLE_PATTERN_FALLBACK" != "true" ]; then
  DEFAULT_CONFIG_PATTERNS=("${DEFAULT_PATTERN_FALLBACK[@]}")
fi

if [ -e $BASE/configs/$HOST ]; then
  log "There is a config for this machine available"
else
  log "No config - press enter to create a new one, ctrl-c to abort..."
  read
  mkdir -p $BASE/configs/$HOST/files
  touch $BASE/configs/$HOST/files.conf
  touch $BASE/configs/$HOST/to_install.$INSTALLER
  touch $BASE/configs/$HOST/includes.conf
  if [ "$INSTALLER" = "brew" ]; then
    touch $BASE/configs/$HOST/taps
  fi

  seed_default_config_files "$HOST"
  log "done"

  echo "Configuration for $HOST created. But this is only a start - please have a closer look at $BASE/config/$HOST" | lolcat
fi

if [ -e $BASE/.git ]; then
  case "$GIT_AUTO_UPDATE" in
  ask)
    while true; do
      logn "Should I try to update configs? (y/n)"
      read a
      if [ "$a" = "n" ]; then
        log "not updating"
        break
      elif [ "$a" = "y" ]; then
        log "updating"
        cd "$BASE"
        git pull || {
          err "Pull failed - continue? (enter / ctrl-c)"
          read
        }
        break
      else
        err "y or n - not $a"
      fi
    done
    ;;
  true)
    cd "$BASE"
    git pull || {
      err "Pull failed -continue? (enter / ctrl-c)"
      read
    }
    ;;
  false)
    echo "Not updating configs"
    ;;
  *)
    echo "Unknown option for GIT_AUTO_UPDATE $GIT_AUTO_UPDATE in config. valid values: true, false, ask"
    exit 1
    ;;
  esac
fi

if [ $# -gt 0 ]; then
  case "$1" in
  --syncSys)
    syncInstall
    syncTTtoSystemFiles
    runLocalInstall
    log "All tasks ${GN}done$RESET"
    log "Logs:"
    cat $TMP/log
    exit 0
    ;;
  --syncFilesOnly)
    syncTTtoSystemFiles
    log "All tasks ${GN}done$RESET"
    log "Logs:"
    cat $TMP/log
    exit 0
    ;;
  --updateToolTamer)
    updateTTFromInstallation
    log "All tasks ${GN}done$RESET"
    log "Logs:"
    cat $TMP/log
    exit 0
    ;;
  --updateToolTamerFiles)
    updateTTFromInstallation
    updatingTTFromSystemFiles
    log "All tasks ${GN}done$RESET"
    log "Logs:"
    cat $TMP/log
    exit 0
    ;;
  --admin)
    source $BINDIR/admin.sh
    exit 0
    ;;
  -h | --help)
    show_help
    exit 0
    ;;
  *)
    err "Unknown option '$1'"
    show_help
    exit 1
    ;;
  esac
fi

export updateSys="Update local installation $HOST from ToolTamer structure\nupdates installed tools, config files on change"
export updateTT="Take a snapshot of current installation\nput files from this installation to ToolTamer"
export show="Show configuration of ToolTamer"

PS3="Choose option -> "
while true; do
  if ! o=$(menu "-----> ${CN}Tool${MG}Tamer$RESET ${BL}V1.0$RESET - main menu" "${BL}U${RESET}pdate System - full system update, local files, installation, local install script" "${BL}F${RESET}iles only - update only files" "${BL}S${RESET}napshot System" "Admin" "Quit"); then
    log "Menu closed - exiting."
    break
  fi
  if [ -z "$o" ]; then
    log "Menu closed - exiting."
    break
  fi
  log "You chose $o"
  opt=$(echo "$o" | cut -f1 -d:)
  # label=$(echo "$o" | cut -f2 -d:)
  case "$opt" in
  "5" | "Q" | "q")
    log "Exiting..."
    exit 0
    ;;
  "1" | "U" | "u")
    syncInstall
    syncTTtoSystemFiles
    runLocalInstall
    pause_before_menu
    ;;
  "2" | "F" | "f")
    syncTTtoSystemFiles
    pause_before_menu
    ;;
  "3" | "s" | "S")
    updateTTFromInstallation
    log "updating TT files from this system"
    updatingTTFromSystemFiles
    pause_before_menu
    ;;
  "4" | "a" | "A")
    source $BINDIR/admin.sh
    ;;
  esac

done

log "All tasks ${GN}done$RESET"

logn "Do you want to see the logs or copy the logs somewhere?"

select o in "See log" "copy log" "quit"; do
  case "$o" in
  "See log")
    cat $TMP/log
    ;;
  "copy log")
    logn "Enter destination - empty would be in /tmp: "
    read d
    if [ -z "$d" ]; then
      d="/tmp"
    fi
    cp $TMP/log $d
    ;;
  "quit")
    break
    ;;
  "*")
    err "Unknown option $o"
    ;;
  esac
done
